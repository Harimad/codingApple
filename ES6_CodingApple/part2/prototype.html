<!DOCTYPE html>
<html lang="en">

<head>
	<meta charset="UTF-8">
	<meta http-equiv="X-UA-Compatible" content="IE=edge">
	<meta name="viewport" content="width=device-width, initial-scale=1.0">
	<title>prototype</title>
</head>

<body>
	<script>
		//작동원리 1
		function 기계() { //기계(constructor)는 전부 prototype이라는 항목을 내부에 몰래 생성
			this.name = 'Kim'; 	//prototype은 부모의 '유전자'역할
			this.age = 15;			//자식은 부모것을 상속받음
		}
		var 학생1 = new 기계();
		var 학생2 = new 기계();

		console.log(기계.prototype); //Object

		기계.prototype.gender = '남';

		console.log(학생1.gender); // '남'
		// 		▲ 학생1.gender라고 사용하면 '남'이 출력되죠? 그 이유는..

		// 자바스크립트는 오브젝트에서 값을 출력할 때 이런 순서로 물어봅니다.
		// (1) 학생1에 직접 gender라는 값이 있는가?
		// (2) 그럼 부모 유전자에 gender라는 값이 있는가?
		// (3) 그럼 부모의 부모 유전자에 gender라는 값이 있는가?
		// (4) 그럼 부모의 부모의 부모의 유전자에 .. 그게 있는가?

		// 자바스크립트는 이런 알고리즘으로 작동합니다.
		// 그냥 쉽게말하자면 오브젝트에서 값을 뽑을 때
		// 1. 내가 직접 가지고 있는지 검사
		// 2. 내가 가지고 있지 않으면 부모 유전자들을 차례로 검사하는구나
		// 라고 잘 기억

		// 작동원리2 : 자바스크립트 내장함수 toString() 을 쓸 수 있는 이유

		// 자바스크립트 array, object 들에는 붙일 수 있는 내장함수들이 많습니다.
		// sort, push, toString, map, forEach 등 이런 것들을 array에 붙여서 사용가능한데 혹시 그 이유가 궁금하지 않으셨습니까

		var arr = [1, 2, 3];
		// var arr = new Array(1,2,3); 윗문장은 이 문장과 같음.
		console.log(arr.toString()); //가능

		// 내가 만든 array에 arr.toString() 이렇게 붙일 수 있는 이유는
		// 내가 만든 array의 부모 유전자가 toString()을 가지고 있기 때문입니다. (혹은 부모의 부모요)

		// Q. 그럼 prototype으로 상속시키는거랑 constructor로 상속시키는거랑 차이가 뭐죠?
		// A. 자식들이 값을 직접 소유하게 만들고 싶으면 constructor로 상속시키시면 되고
		// 부모만 가지고 있고 그걸 참조해서 쓰게 만들고 싶으면 prototype으로 상속시키면 되겠죠?
		// 보통은 그래서 상속할 수 있는 함수 같은 것들은 prototype으로 많이 만들어놓습니다.
	</script>
</body>

</html>
